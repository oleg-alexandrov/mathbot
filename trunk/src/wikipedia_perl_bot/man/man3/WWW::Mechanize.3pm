.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::Mechanize 3pm"
.TH WWW::Mechanize 3pm "2007-02-13" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
WWW::Mechanize \- Handy web browsing in a Perl object
.SH "VERSION"
.IX Header "VERSION"
Version 1.30
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`WWW::Mechanize\*(C'\fR, or Mech for short, helps you automate interaction with
a website. It supports performing a sequence of page fetches including
following links and submitting forms. Each fetched page is parsed and
its links and forms are extracted. A link or a form can be selected, form
fields can be filled and the next page can be fetched. Mech also stores
a history of the URLs you've visited, which can be queried and revisited.
.PP
.Vb 2
\&    use WWW::Mechanize;
\&    my $mech = WWW::Mechanize\->new();
.Ve
.PP
.Vb 1
\&    $mech\->get( $url );
.Ve
.PP
.Vb 3
\&    $mech\->follow_link( n => 3 );
\&    $mech\->follow_link( text_regex => qr/download this/i );
\&    $mech\->follow_link( url => 'http://host.com/index.html' );
.Ve
.PP
.Vb 7
\&    $mech\->submit_form(
\&        form_number => 3,
\&        fields      => {
\&            username    => 'mungo',
\&            password    => 'lost\-and\-alone',
\&        }
\&    );
.Ve
.PP
.Vb 5
\&    $mech\->submit_form(
\&        form_name => 'search',
\&        fields    => { query  => 'pot of gold', },
\&        button    => 'Search Now'
\&    );
.Ve
.PP
Mech is well suited for use in testing web applications.  If you use
one of the Test::*, like Test::HTML::Lint modules, you can check the
fetched content and use that as input to a test call.
.PP
.Vb 2
\&    use Test::More;
\&    like( $mech\->content(), qr/$expected/, "Got expected content" );
.Ve
.PP
Each page fetch stores its \s-1URL\s0 in a history stack which you can
traverse.
.PP
.Vb 1
\&    $mech\->back();
.Ve
.PP
If you want finer control over over your page fetching, you can use
these methods. \f(CW\*(C`follow_link\*(C'\fR and \f(CW\*(C`submit_form\*(C'\fR are just high
level wrappers around them.
.PP
.Vb 7
\&    $mech\->find_link( n => $number );
\&    $mech\->form_number( $number );
\&    $mech\->form_name( $name );
\&    $mech\->field( $name, $value );
\&    $mech\->set_fields( %field_values );
\&    $mech\->set_visible( @criteria );
\&    $mech\->click( $button );
.Ve
.PP
WWW::Mechanize is a proper subclass of LWP::UserAgent and
you can also use any of LWP::UserAgent's methods.
.PP
.Vb 1
\&    $mech\->add_header($name => $value);
.Ve
.PP
Please note that Mech does \s-1NOT\s0 support JavaScript.  Please check the
\&\s-1FAQ\s0 in WWW::Mechanize::FAQ for more.
.SH "IMPORTANT LINKS"
.IX Header "IMPORTANT LINKS"
.IP "* <http://search.cpan.org/dist/WWW\-Mechanize/>" 4
.IX Item "<http://search.cpan.org/dist/WWW-Mechanize/>"
The \s-1CPAN\s0 documentation page for Mechanize.
.IP "* <http://search.cpan.org/dist/WWW\-Mechanize/lib/WWW/Mechanize/FAQ.pod>" 4
.IX Item "<http://search.cpan.org/dist/WWW-Mechanize/lib/WWW/Mechanize/FAQ.pod>"
Frequently asked questions.  Make sure you read here \s-1FIRST\s0.
.IP "* <http://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW\-Mechanize>" 4
.IX Item "<http://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW-Mechanize>"
The \s-1RT\s0 queue for bugs & enhancements in Mechanize.  Click the \*(L"Report bug\*(R"
link if your bug isn't already reported.
.SH "CONSTRUCTOR AND STARTUP"
.IX Header "CONSTRUCTOR AND STARTUP"
.Sh "\fInew()\fP"
.IX Subsection "new()"
Creates and returns a new WWW::Mechanize object, hereafter referred to as
the \*(L"agent\*(R".
.PP
.Vb 1
\&    my $mech = WWW::Mechanize\->new()
.Ve
.PP
The constructor for WWW::Mechanize overrides two of the parms to the
LWP::UserAgent constructor:
.PP
.Vb 2
\&    agent => 'WWW\-Mechanize/#.##'
\&    cookie_jar => {}    # an empty, memory\-only HTTP::Cookies object
.Ve
.PP
You can override these overrides by passing parms to the constructor,
as in:
.PP
.Vb 1
\&    my $mech = WWW::Mechanize\->new( agent => 'wonderbot 1.01' );
.Ve
.PP
If you want none of the overhead of a cookie jar, or don't want your
bot accepting cookies, you have to explicitly disallow it, like so:
.PP
.Vb 1
\&    my $mech = WWW::Mechanize\->new( cookie_jar => undef );
.Ve
.PP
Here are the parms that WWW::Mechanize recognizes.  These do not include
parms that LWP::UserAgent recognizes.
.ie n .IP "* ""autocheck => [0|1]""" 4
.el .IP "* \f(CWautocheck => [0|1]\fR" 4
.IX Item "autocheck => [0|1]"
Checks each request made to see if it was successful.  This saves you
the trouble of manually checking yourself.  Any errors found are errors,
not warnings.  Default is off.
.ie n .IP "* ""onwarn => \e&func""" 4
.el .IP "* \f(CWonwarn => \e&func\fR" 4
.IX Item "onwarn => &func"
Reference to a \f(CW\*(C`warn\*(C'\fR\-compatible function, such as \f(CW\*(C`Carp::carp\*(C'\fR,
that is called when a warning needs to be shown.
.Sp
If this is set to \f(CW\*(C`undef\*(C'\fR, no warnings will ever be shown.  However,
it's probably better to use the \f(CW\*(C`quiet\*(C'\fR method to control that behavior.
.Sp
If this value is not passed, Mech uses \f(CW\*(C`Carp::carp\*(C'\fR if Carp is
installed, or \f(CW\*(C`CORE::warn\*(C'\fR if not.
.ie n .IP "* ""onerror => \e&func""" 4
.el .IP "* \f(CWonerror => \e&func\fR" 4
.IX Item "onerror => &func"
Reference to a \f(CW\*(C`die\*(C'\fR\-compatible function, such as \f(CW\*(C`Carp::croak\*(C'\fR,
that is called when there's a fatal error.
.Sp
If this is set to \f(CW\*(C`undef\*(C'\fR, no errors will ever be shown.
.Sp
If this value is not passed, Mech uses \f(CW\*(C`Carp::croak\*(C'\fR if Carp is
installed, or \f(CW\*(C`CORE::die\*(C'\fR if not.
.ie n .IP "* ""quiet => [0|1]""" 4
.el .IP "* \f(CWquiet => [0|1]\fR" 4
.IX Item "quiet => [0|1]"
Don't complain on warnings.  Setting \f(CW\*(C`quiet => 1\*(C'\fR is the same as
calling \f(CW\*(C`$mech\->quiet(1)\*(C'\fR.  Default is off.
.ie n .IP "* ""stack_depth => $value""" 4
.el .IP "* \f(CWstack_depth => $value\fR" 4
.IX Item "stack_depth => $value"
Sets the depth of the page stack that keeps tracks of all the downloaded
pages. Default is 0 (infinite). If the stack is eating up your memory,
then set it to 1.
.ie n .Sh "$mech\->agent_alias( $alias )"
.el .Sh "$mech\->agent_alias( \f(CW$alias\fP )"
.IX Subsection "$mech->agent_alias( $alias )"
Sets the user agent string to the expanded version from a table of actual user strings.
\&\fI$alias\fR can be one of the following:
.IP "* Windows \s-1IE\s0 6" 4
.IX Item "Windows IE 6"
.PD 0
.IP "* Windows Mozilla" 4
.IX Item "Windows Mozilla"
.IP "* Mac Safari" 4
.IX Item "Mac Safari"
.IP "* Mac Mozilla" 4
.IX Item "Mac Mozilla"
.IP "* Linux Mozilla" 4
.IX Item "Linux Mozilla"
.IP "* Linux Konqueror" 4
.IX Item "Linux Konqueror"
.PD
.PP
then it will be replaced with a more interesting one.  For instance,
.PP
.Vb 1
\&    $mech\->agent_alias( 'Windows IE 6' );
.Ve
.PP
sets your User-Agent to
.PP
.Vb 1
\&    Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
.Ve
.PP
The list of valid aliases can be returned from \f(CW\*(C`known_agent_aliases()\*(C'\fR.  The current list is:
.IP "* Windows \s-1IE\s0 6" 4
.IX Item "Windows IE 6"
.PD 0
.IP "* Windows Mozilla" 4
.IX Item "Windows Mozilla"
.IP "* Mac Safari" 4
.IX Item "Mac Safari"
.IP "* Mac Mozilla" 4
.IX Item "Mac Mozilla"
.IP "* Linux Mozilla" 4
.IX Item "Linux Mozilla"
.IP "* Linux Konqueror" 4
.IX Item "Linux Konqueror"
.PD
.Sh "\fIknown_agent_aliases()\fP"
.IX Subsection "known_agent_aliases()"
Returns a list of all the agent aliases that Mech knows about.
.SH "PAGE-FETCHING METHODS"
.IX Header "PAGE-FETCHING METHODS"
.ie n .Sh "$mech\->get( $uri )"
.el .Sh "$mech\->get( \f(CW$uri\fP )"
.IX Subsection "$mech->get( $uri )"
Given a \s-1URL/URI\s0, fetches it.  Returns an HTTP::Response object.
\&\fI$uri\fR can be a well-formed \s-1URL\s0 string, a \s-1URI\s0 object, or a
WWW::Mechanize::Link object.
.PP
The results are stored internally in the agent object, but you don't
know that.  Just use the accessors listed below.  Poking at the internals
is deprecated and subject to change in the future.
.PP
\&\f(CW\*(C`get()\*(C'\fR is a well-behaved overloaded version of the method in
LWP::UserAgent.  This lets you do things like
.PP
.Vb 1
\&    $mech\->get( $uri, ':content_file' => $tempfile );
.Ve
.PP
and you can rest assured that the parms will get filtered down
appropriately.
.ie n .Sh "$mech\->put( $uri\fP, content => \f(CW$content )"
.el .Sh "$mech\->put( \f(CW$uri\fP, content => \f(CW$content\fP )"
.IX Subsection "$mech->put( $uri, content => $content )"
PUTs \fI$content\fR to \f(CW$uri\fR.  Returns an HTTP::Response object.
\&\fI$uri\fR can be a well-formed \s-1URI\s0 string, a \s-1URI\s0 object, or a
WWW::Mechanize::Link object.
.Sh "$mech\->\fIreload()\fP"
.IX Subsection "$mech->reload()"
Acts like the reload button in a browser: repeats the current
request. The history (as per the back method) is not altered.
.PP
Returns the HTTP::Response object from the reload, or \f(CW\*(C`undef\*(C'\fR
if there's no current request.
.Sh "$mech\->\fIback()\fP"
.IX Subsection "$mech->back()"
The equivalent of hitting the \*(L"back\*(R" button in a browser.  Returns to
the previous page.  Won't go back past the first page. (Really, what
would it do if it could?)
.SH "STATUS METHODS"
.IX Header "STATUS METHODS"
.Sh "$mech\->\fIsuccess()\fP"
.IX Subsection "$mech->success()"
Returns a boolean telling whether the last request was successful.
If there hasn't been an operation yet, returns false.
.PP
This is a convenience function that wraps \f(CW\*(C`$mech\->res\->is_success\*(C'\fR.
.Sh "$mech\->\fIuri()\fP"
.IX Subsection "$mech->uri()"
Returns the current \s-1URI\s0 as a \s-1URI\s0 object. This object stringifies
to the \s-1URI\s0 itself.
.ie n .Sh "$mech\->\fIresponse()\fP / $mech\fP\->\fIres()"
.el .Sh "$mech\->\fIresponse()\fP / \f(CW$mech\fP\->\fIres()\fP"
.IX Subsection "$mech->response() / $mech->res()"
Return the current response as an HTTP::Response object.
.PP
Synonym for \f(CW\*(C`$mech\->response()\*(C'\fR
.Sh "$mech\->\fIstatus()\fP"
.IX Subsection "$mech->status()"
Returns the \s-1HTTP\s0 status code of the response.
.Sh "$mech\->\fIct()\fP"
.IX Subsection "$mech->ct()"
Returns the content type of the response.
.Sh "$mech\->\fIbase()\fP"
.IX Subsection "$mech->base()"
Returns the base \s-1URI\s0 for the current response
.Sh "$mech\->\fIforms()\fP"
.IX Subsection "$mech->forms()"
When called in a list context, returns a list of the forms found in
the last fetched page. In a scalar context, returns a reference to
an array with those forms. The forms returned are all HTML::Form
objects.
.Sh "$mech\->\fIcurrent_form()\fP"
.IX Subsection "$mech->current_form()"
Returns the current form as an HTML::Form object.
.Sh "$mech\->\fIlinks()\fP"
.IX Subsection "$mech->links()"
When called in a list context, returns a list of the links found in the
last fetched page.  In a scalar context it returns a reference to an array
with those links.  Each link is a WWW::Mechanize::Link object.
.Sh "$mech\->\fIis_html()\fP"
.IX Subsection "$mech->is_html()"
Returns true/false on whether our content is \s-1HTML\s0, according to the
\&\s-1HTTP\s0 headers.
.Sh "$mech\->\fItitle()\fP"
.IX Subsection "$mech->title()"
Returns the contents of the \f(CW\*(C`<TITLE>\*(C'\fR tag, as parsed by
HTML::HeadParser.  Returns undef if the content is not \s-1HTML\s0.
.SH "CONTENT-HANDLING METHODS"
.IX Header "CONTENT-HANDLING METHODS"
.Sh "$mech\->content(...)"
.IX Subsection "$mech->content(...)"
Returns the content that the mech uses internally for the last page
fetched. Ordinarily this is the same as \f(CW$mech\fR\->\fIresponse()\fR\->\fIcontent()\fR,
but this may differ for \s-1HTML\s0 documents if \*(L"update_html\*(R" is
overloaded (in which case the value passed to the base-class
implementation of same will be returned), and/or extra named arguments
are passed to \fI\fIcontent()\fI\fR:
.IP "\fI$mech\->content( format => 'text' )\fR" 2
.IX Item "$mech->content( format => 'text' )"
Returns a text-only version of the page, with all \s-1HTML\s0 markup
stripped. This feature requires \fIHTML::TreeBuilder\fR to be installed,
or a fatal error will be thrown.
.IP "\fI$mech\->content( base_href => [$base_href|undef] )\fR" 2
.IX Item "$mech->content( base_href => [$base_href|undef] )"
Returns the \s-1HTML\s0 document, modified to contain a
\&\f(CW\*(C`<base href="$base_href">\*(C'\fR mark-up in the header.
\&\fI$base_href\fR is \f(CW\*(C`$mech\->base()\*(C'\fR if not specified. This is
handy to pass the \s-1HTML\s0 to e.g. HTML::Display.
.PP
Passing arguments to \f(CW\*(C`content()\*(C'\fR if the current document is not
\&\s-1HTML\s0 has no effect now (i.e. the return value is the same as
\&\f(CW\*(C`$self\->response()\->content()\*(C'\fR. This may change in the future,
but will likely be backwards-compatible when it does.
.SH "LINK METHODS"
.IX Header "LINK METHODS"
.Sh "$mech\->links"
.IX Subsection "$mech->links"
Lists all the links on the current page.  Each link is a
WWW::Mechanize::Link object. In list context, returns a list of all
links.  In scalar context, returns an array reference of all links.
.Sh "$mech\->follow_link(...)"
.IX Subsection "$mech->follow_link(...)"
Follows a specified link on the page.  You specify the match to be
found using the same parms that \f(CW\*(C`\f(CIfind_link()\f(CW\*(C'\fR uses.
.PP
Here some examples:
.ie n .IP "* 3rd link called ""download""" 4
.el .IP "* 3rd link called ``download''" 4
.IX Item "3rd link called download"
.Vb 1
\&    $mech\->follow_link( text => 'download', n => 3 );
.Ve
.ie n .IP "* first link where the \s-1URL\s0 has ""download"" in it, regardless of case:" 4
.el .IP "* first link where the \s-1URL\s0 has ``download'' in it, regardless of case:" 4
.IX Item "first link where the URL has download in it, regardless of case:"
.Vb 1
\&    $mech\->follow_link( url_regex => qr/download/i );
.Ve
.Sp
or
.Sp
.Vb 1
\&    $mech\->follow_link( url_regex => qr/(?i:download)/ );
.Ve
.IP "* 3rd link on the page" 4
.IX Item "3rd link on the page"
.Vb 1
\&    $mech\->follow_link( n => 3 );
.Ve
.PP
Returns the result of the \s-1GET\s0 method (an HTTP::Response object) if
a link was found. If the page has no links, or the specified link
couldn't be found, returns undef.
.Sh "$mech\->find_link( ... )"
.IX Subsection "$mech->find_link( ... )"
Finds a link in the currently fetched page. It returns a
WWW::Mechanize::Link object which describes the link.  (You'll
probably be most interested in the \f(CW\*(C`url()\*(C'\fR property.)  If it fails
to find a link it returns undef.
.PP
You can take the \s-1URL\s0 part and pass it to the \f(CW\*(C`get()\*(C'\fR method.  If
that's your plan, you might as well use the \f(CW\*(C`follow_link()\*(C'\fR method
directly, since it does the \f(CW\*(C`get()\*(C'\fR for you automatically.
.PP
Note that \f(CW\*(C`<FRAME SRC="...">\*(C'\fR tags are parsed out of the the \s-1HTML\s0
and treated as links so this method works with them.
.PP
You can select which link to find by passing in one or more of these
key/value pairs:
.ie n .IP "* ""text => 'string',""\fR and \f(CW""text_regex => qr/regex/,""" 4
.el .IP "* \f(CWtext => 'string',\fR and \f(CWtext_regex => qr/regex/,\fR" 4
.IX Item "text => 'string', and text_regex => qr/regex/,"
\&\f(CW\*(C`text\*(C'\fR matches the text of the link against \fIstring\fR, which must be an
exact match.  To select a link with text that is exactly \*(L"download\*(R", use
.Sp
.Vb 1
\&    $mech\->find_link( text => 'download' );
.Ve
.Sp
\&\f(CW\*(C`text_regex\*(C'\fR matches the text of the link against \fIregex\fR.  To select a
link with text that has \*(L"download\*(R" anywhere in it, regardless of case, use
.Sp
.Vb 1
\&    $mech\->find_link( text_regex => qr/download/i );
.Ve
.Sp
Note that the text extracted from the page's links are trimmed.  For
example, \f(CW\*(C`<a> foo </a>\*(C'\fR is stored as 'foo', and searching for
leading or trailing spaces will fail.
.ie n .IP "* ""url => 'string',""\fR and \f(CW""url_regex => qr/regex/,""" 4
.el .IP "* \f(CWurl => 'string',\fR and \f(CWurl_regex => qr/regex/,\fR" 4
.IX Item "url => 'string', and url_regex => qr/regex/,"
Matches the \s-1URL\s0 of the link against \fIstring\fR or \fIregex\fR, as appropriate.
The \s-1URL\s0 may be a relative \s-1URL\s0, like \fIfoo/bar.html\fR, depending on how
it's coded on the page.
.ie n .IP "* ""url_abs => string""\fR and \f(CW""url_abs_regex => regex""" 4
.el .IP "* \f(CWurl_abs => string\fR and \f(CWurl_abs_regex => regex\fR" 4
.IX Item "url_abs => string and url_abs_regex => regex"
Matches the absolute \s-1URL\s0 of the link against \fIstring\fR or \fIregex\fR,
as appropriate.  The \s-1URL\s0 will be an absolute \s-1URL\s0, even if it's relative
in the page.
.ie n .IP "* ""name => string""\fR and \f(CW""name_regex => regex""" 4
.el .IP "* \f(CWname => string\fR and \f(CWname_regex => regex\fR" 4
.IX Item "name => string and name_regex => regex"
Matches the name of the link against \fIstring\fR or \fIregex\fR, as appropriate.
.ie n .IP "* ""tag => string""\fR and \f(CW""tag_regex => regex""" 4
.el .IP "* \f(CWtag => string\fR and \f(CWtag_regex => regex\fR" 4
.IX Item "tag => string and tag_regex => regex"
Matches the tag that the link came from against \fIstring\fR or \fIregex\fR,
as appropriate.  The \f(CW\*(C`tag_regex\*(C'\fR is probably most useful to check for
more than one tag, as in:
.Sp
.Vb 1
\&    $mech\->find_link( tag_regex => qr/^(a|frame)$/ );
.Ve
.Sp
The tags and attributes looked at are defined below, at
\&\*(L"$mech\->\fIfind_link()\fR : link format\*(R".
.PP
If \f(CW\*(C`n\*(C'\fR is not specified, it defaults to 1.  Therefore, if you don't
specify any parms, this method defaults to finding the first link on the
page.
.PP
Note that you can specify multiple text or \s-1URL\s0 parameters, which
will be ANDed together.  For example, to find the first link with
text of \*(L"News\*(R" and with \*(L"cnn.com\*(R" in the \s-1URL\s0, use:
.PP
.Vb 1
\&    $mech\->find_link( text => 'News', url_regex => qr/cnn\e.com/ );
.Ve
.PP
The return value is a reference to an array containing a
WWW::Mechanize::Link object for every link in \f(CW\*(C`$self\->content\*(C'\fR.
.PP
The links come from the following:
.ie n .IP """<A HREF=...>""" 4
.el .IP "\f(CW<A HREF=...>\fR" 4
.IX Item "<A HREF=...>"
.PD 0
.ie n .IP """<AREA HREF=...>""" 4
.el .IP "\f(CW<AREA HREF=...>\fR" 4
.IX Item "<AREA HREF=...>"
.ie n .IP """<FRAME SRC=...>""" 4
.el .IP "\f(CW<FRAME SRC=...>\fR" 4
.IX Item "<FRAME SRC=...>"
.ie n .IP """<IFRAME SRC=...>""" 4
.el .IP "\f(CW<IFRAME SRC=...>\fR" 4
.IX Item "<IFRAME SRC=...>"
.ie n .IP """<META CONTENT=...>""" 4
.el .IP "\f(CW<META CONTENT=...>\fR" 4
.IX Item "<META CONTENT=...>"
.PD
.Sh "$mech\->find_all_links( ... )"
.IX Subsection "$mech->find_all_links( ... )"
Returns all the links on the current page that match the criteria.  The
method for specifying link criteria is the same as in \f(CW\*(C`\f(CIfind_link()\f(CW\*(C'\fR.
Each of the links returned is a WWW::Mechanize::Link object.
.PP
In list context, \f(CW\*(C`find_all_links()\*(C'\fR returns a list of the links.
Otherwise, it returns a reference to the list of links.
.PP
\&\f(CW\*(C`find_all_links()\*(C'\fR with no parameters returns all links in the
page.
.Sh "$mech\->find_all_inputs( ... criteria ... )"
.IX Subsection "$mech->find_all_inputs( ... criteria ... )"
\&\fIfind_all_inputs()\fR returns an array of all the input controls in the
current form whose properties match all of the regexes passed in.
The controls returned are all descended from HTML::Form::Input.
.PP
If no criteria are passed, all inputs will be returned.
.PP
If there is no current page, there is no form on the current
page, or there are no submit controls in the current form
then the return will be an empty array.
.PP
You may use a regex or a literal string:
.PP
.Vb 7
\&    # get all textarea controls whose names begin with "customer"
\&    my @customer_text_inputs =
\&        $mech\->find_all_inputs( {
\&            type       => 'textarea',
\&            name_regex => qr/^customer/,
\&        }
\&    );
.Ve
.PP
.Vb 7
\&    # get all text or textarea controls called "customer"
\&    my @customer_text_inputs =
\&        $mech\->find_all_inputs( {
\&            type_regex => qr/^(text|textarea)$/,
\&            name       => 'customer',
\&        }
\&    );
.Ve
.Sh "$mech\->find_all_submits( ... criteria ... )"
.IX Subsection "$mech->find_all_submits( ... criteria ... )"
\&\f(CW\*(C`find_all_submits()\*(C'\fR does the same thing as \f(CW\*(C`find_all_inputs()\*(C'\fR
except that it only returns controls that are submit controls,
ignoring other types of input controls like text and checkboxes.
.SH "IMAGE METHODS"
.IX Header "IMAGE METHODS"
.Sh "$mech\->images"
.IX Subsection "$mech->images"
Lists all the images on the current page.  Each image is a
WWW::Mechanize::Image object. In list context, returns a list of all
images.  In scalar context, returns an array reference of all images.
.Sh "$mech\->\fIfind_image()\fP"
.IX Subsection "$mech->find_image()"
Finds an image in the current page. It returns a
WWW::Mechanize::Image object which describes the image.  If it fails
to find an image it returns undef.
.PP
You can select which link to find by passing in one or more of these
key/value pairs:
.ie n .IP "* ""alt => 'string'""\fR and \f(CW""alt_regex => qr/regex/,""" 4
.el .IP "* \f(CWalt => 'string'\fR and \f(CWalt_regex => qr/regex/,\fR" 4
.IX Item "alt => 'string' and alt_regex => qr/regex/,"
\&\f(CW\*(C`alt\*(C'\fR matches the \s-1ALT\s0 attribute of the image against \fIstring\fR, which must be an
exact match. To select a image with an \s-1ALT\s0 tag that is exactly \*(L"download\*(R", use
.Sp
.Vb 1
\&    $mech\->find_image( alt => 'download' );
.Ve
.Sp
\&\f(CW\*(C`alt_regex\*(C'\fR matches the \s-1ALT\s0 attribute of the image  against a regular
expression.  To select an image with an \s-1ALT\s0 attribute that has \*(L"download\*(R"
anywhere in it, regardless of case, use
.Sp
.Vb 1
\&    $mech\->find_image( alt_regex => qr/download/i );
.Ve
.ie n .IP "* ""url => 'string',""\fR and \f(CW""url_regex => qr/regex/,""" 4
.el .IP "* \f(CWurl => 'string',\fR and \f(CWurl_regex => qr/regex/,\fR" 4
.IX Item "url => 'string', and url_regex => qr/regex/,"
Matches the \s-1URL\s0 of the image against \fIstring\fR or \fIregex\fR, as appropriate.
The \s-1URL\s0 may be a relative \s-1URL\s0, like \fIfoo/bar.html\fR, depending on how
it's coded on the page.
.ie n .IP "* ""url_abs => string""\fR and \f(CW""url_abs_regex => regex""" 4
.el .IP "* \f(CWurl_abs => string\fR and \f(CWurl_abs_regex => regex\fR" 4
.IX Item "url_abs => string and url_abs_regex => regex"
Matches the absolute \s-1URL\s0 of the image against \fIstring\fR or \fIregex\fR,
as appropriate.  The \s-1URL\s0 will be an absolute \s-1URL\s0, even if it's relative
in the page.
.ie n .IP "* ""tag => string""\fR and \f(CW""tag_regex => regex""" 4
.el .IP "* \f(CWtag => string\fR and \f(CWtag_regex => regex\fR" 4
.IX Item "tag => string and tag_regex => regex"
Matches the tag that the image came from against \fIstring\fR or \fIregex\fR,
as appropriate.  The \f(CW\*(C`tag_regex\*(C'\fR is probably most useful to check for
more than one tag, as in:
.Sp
.Vb 1
\&    $mech\->find_image( tag_regex => qr/^(img|input)$/ );
.Ve
.Sp
The tags supported are \f(CW\*(C`<img>\*(C'\fR and \f(CW\*(C`<input>\*(C'\fR.
.PP
If \f(CW\*(C`n\*(C'\fR is not specified, it defaults to 1.  Therefore, if you don't
specify any parms, this method defaults to finding the first image on the
page.
.PP
Note that you can specify multiple \s-1ALT\s0 or \s-1URL\s0 parameters, which
will be ANDed together.  For example, to find the first image with
\&\s-1ALT\s0 text of \*(L"News\*(R" and with \*(L"cnn.com\*(R" in the \s-1URL\s0, use:
.PP
.Vb 1
\&    $mech\->find_image( image => 'News', url_regex => qr/cnn\e.com/ );
.Ve
.PP
The return value is a reference to an array containing a
WWW::Mechanize::Image object for every image in \f(CW\*(C`$self\->content\*(C'\fR.
.Sh "$mech\->find_all_images( ... )"
.IX Subsection "$mech->find_all_images( ... )"
Returns all the images on the current page that match the criteria.  The
method for specifying image criteria is the same as in \f(CW\*(C`\f(CIfind_image()\f(CW\*(C'\fR.
Each of the images returned is a WWW::Mechanize::Image object.
.PP
In list context, \f(CW\*(C`find_all_images()\*(C'\fR returns a list of the images.
Otherwise, it returns a reference to the list of images.
.PP
\&\f(CW\*(C`find_all_images()\*(C'\fR with no parameters returns all images in the page.
.SH "FORM METHODS"
.IX Header "FORM METHODS"
.Sh "$mech\->forms"
.IX Subsection "$mech->forms"
Lists all the forms on the current page.  Each form is an HTML::Form
object.  In list context, returns a list of all forms.  In scalar
context, returns an array reference of all forms.
.Sh "$mech\->form_number($number)"
.IX Subsection "$mech->form_number($number)"
Selects the \fInumber\fRth form on the page as the target for subsequent
calls to \f(CW\*(C`\f(CIfield()\f(CW\*(C'\fR and \f(CW\*(C`\f(CIclick()\f(CW\*(C'\fR.  Also returns the form that was
selected.
.PP
If it is found, the form is returned as an HTML::Form object and set internally
for later used with Mech's form methods such as \f(CW\*(C`\f(CIfield()\f(CW\*(C'\fR and \f(CW\*(C`\f(CIclick()\f(CW\*(C'\fR.
.PP
Emits a warning and returns undef if no form is found.
.PP
The first form is number 1, not zero.
.ie n .Sh "$mech\->form_name( $name )"
.el .Sh "$mech\->form_name( \f(CW$name\fP )"
.IX Subsection "$mech->form_name( $name )"
Selects a form by name.  If there is more than one form on the page
with that name, then the first one is used, and a warning is
generated.
.PP
If it is found, the form is returned as an HTML::Form object and set internally
for later used with Mech's form methods such as \f(CW\*(C`\f(CIfield()\f(CW\*(C'\fR and \f(CW\*(C`\f(CIclick()\f(CW\*(C'\fR.
.PP
Returns undef if no form is found.
.PP
Note that this functionality requires libwww-perl 5.69 or higher.
.ie n .Sh "$mech\->form_with_fields( @fields )"
.el .Sh "$mech\->form_with_fields( \f(CW@fields\fP )"
.IX Subsection "$mech->form_with_fields( @fields )"
Selects a form by passing in a list of field names it must contain.  If there
is more than one form on the page with that matches, then the first one is used,
and a warning is generated.
.PP
If it is found, the form is returned as an HTML::Form object and set internally
for later used with Mech's form methods such as \f(CW\*(C`\f(CIfield()\f(CW\*(C'\fR and \f(CW\*(C`\f(CIclick()\f(CW\*(C'\fR.
.PP
Returns undef if no form is found.
.PP
Note that this functionality requires libwww-perl 5.69 or higher.
.ie n .Sh "$mech\->field( $name\fP, \f(CW$value\fP, \f(CW$number )"
.el .Sh "$mech\->field( \f(CW$name\fP, \f(CW$value\fP, \f(CW$number\fP )"
.IX Subsection "$mech->field( $name, $value, $number )"
.ie n .Sh "$mech\->field( $name\fP, \e@values, \f(CW$number )"
.el .Sh "$mech\->field( \f(CW$name\fP, \e@values, \f(CW$number\fP )"
.IX Subsection "$mech->field( $name, @values, $number )"
Given the name of a field, set its value to the value specified.  This
applies to the current form (as set by the \fIform_name()\fR or \fIform_number()\fR method or defaulting
to the first form on the page).
.PP
The optional \fI$number\fR parameter is used to distinguish between two fields
with the same name.  The fields are numbered from 1.
.ie n .Sh "$mech\->select($name, $value)"
.el .Sh "$mech\->select($name, \f(CW$value\fP)"
.IX Subsection "$mech->select($name, $value)"
.Sh "$mech\->select($name, \e@values)"
.IX Subsection "$mech->select($name, @values)"
Given the name of a \f(CW\*(C`select\*(C'\fR field, set its value to the value
specified.  If the field is not <select multiple> and the
\&\f(CW$value\fR is an array, only the \fBfirst\fR value will be set.  [Note:
the documentation previously claimed that only the last value would
be set, but this was incorrect.]  Passing \f(CW$value\fR as a hash with
an \f(CW\*(C`n\*(C'\fR key selects an item by number (e.g. \f(CW\*(C`{n =\*(C'\fR 3> or \f(CW\*(C`{n =\*(C'\fR [2,4]}>).
The numbering starts at 1.  This applies to the current form.
.PP
Returns 1 on successfully setting the value. On failure, returns
undef and calls \f(CW\*(C`$self>warn()\*(C'\fR with an error message.
.ie n .Sh "$mech\->set_fields( $name\fP => \f(CW$value ... )"
.el .Sh "$mech\->set_fields( \f(CW$name\fP => \f(CW$value\fP ... )"
.IX Subsection "$mech->set_fields( $name => $value ... )"
This method sets multiple fields of the current form. It takes a list
of field name and value pairs. If there is more than one field with
the same name, the first one found is set. If you want to select which
of the duplicate field to set, use a value which is an anonymous array
which has the field value and its number as the 2 elements.
.PP
.Vb 2
\&        # set the second foo field
\&        $mech\->set_fields( $name => [ 'foo', 2 ] ) ;
.Ve
.PP
The fields are numbered from 1.
.PP
This applies to the current form.
.ie n .Sh "$mech\->set_visible( @criteria )"
.el .Sh "$mech\->set_visible( \f(CW@criteria\fP )"
.IX Subsection "$mech->set_visible( @criteria )"
This method sets fields of the current form without having to know
their names.  So if you have a login screen that wants a username and
password, you do not have to fetch the form and inspect the source (or
use the \fImech-dump\fR utility, installed with WWW::Mechanize) to see
what the field names are; you can just say
.PP
.Vb 1
\&    $mech\->set_visible( $username, $password ) ;
.Ve
.PP
and the first and second fields will be set accordingly.  The method
is called set_\fIvisible\fR because it acts only on visible fields;
hidden form inputs are not considered.  The order of the fields is
the order in which they appear in the \s-1HTML\s0 source which is nearly
always the order anyone viewing the page would think they are in,
but some creative work with tables could change that; caveat user.
.PP
Each element in \f(CW@criteria\fR is either a field value or a field
specifier.  A field value is a scalar.  A field specifier allows
you to specify the \fItype\fR of input field you want to set and is
denoted with an arrayref containing two elements.  So you could
specify the first radio button with
.PP
.Vb 1
\&    $mech\->set_visible( [ radio => 'KCRW' ] ) ;
.Ve
.PP
Field values and specifiers can be intermixed, hence
.PP
.Vb 1
\&    $mech\->set_visible( 'fred', 'secret', [ option => 'Checking' ] ) ;
.Ve
.PP
would set the first two fields to \*(L"fred\*(R" and \*(L"secret\*(R", and the \fInext\fR
\&\f(CW\*(C`OPTION\*(C'\fR menu field to \*(L"Checking\*(R".
.PP
The possible field specifier types are: \*(L"text\*(R", \*(L"password\*(R", \*(L"hidden\*(R",
\&\*(L"textarea\*(R", \*(L"file\*(R", \*(L"image\*(R", \*(L"submit\*(R", \*(L"radio\*(R", \*(L"checkbox\*(R" and \*(L"option\*(R".
.PP
\&\f(CW\*(C`set_visible\*(C'\fR returns the number of values set.
.ie n .Sh "$mech\->tick( $name\fP, \f(CW$value\fP [, \f(CW$set] )"
.el .Sh "$mech\->tick( \f(CW$name\fP, \f(CW$value\fP [, \f(CW$set\fP] )"
.IX Subsection "$mech->tick( $name, $value [, $set] )"
\&\*(L"Ticks\*(R" the first checkbox that has both the name and value associated
with it on the current form.  Dies if there is no named check box for
that value.  Passing in a false value as the third optional argument
will cause the checkbox to be unticked.
.ie n .Sh "$mech\->untick($name, $value)"
.el .Sh "$mech\->untick($name, \f(CW$value\fP)"
.IX Subsection "$mech->untick($name, $value)"
Causes the checkbox to be unticked.  Shorthand for
\&\f(CW\*(C`tick($name,$value,undef)\*(C'\fR
.ie n .Sh "$mech\->value( $name\fP, \f(CW$number )"
.el .Sh "$mech\->value( \f(CW$name\fP, \f(CW$number\fP )"
.IX Subsection "$mech->value( $name, $number )"
Given the name of a field, return its value. This applies to the current
form.
.PP
The option \fI$number\fR parameter is used to distinguish between two fields
with the same name.  The fields are numbered from 1.
.PP
If the field is of type file (file upload field), the value is always
cleared to prevent remote sites from downloading your local files.
To upload a file, specify its file name explicitly.
.ie n .Sh "$mech\->click( $button\fP [, \f(CW$x\fP, \f(CW$y] )"
.el .Sh "$mech\->click( \f(CW$button\fP [, \f(CW$x\fP, \f(CW$y\fP] )"
.IX Subsection "$mech->click( $button [, $x, $y] )"
Has the effect of clicking a button on the current form.  The first
argument is the name of the button to be clicked.  The second and
third arguments (optional) allow you to specify the (x,y) coordinates
of the click.
.PP
If there is only one button on the form, \f(CW\*(C`$mech\->click()\*(C'\fR with
no arguments simply clicks that one button.
.PP
Returns an HTTP::Response object.
.Sh "$mech\->click_button( ... )"
.IX Subsection "$mech->click_button( ... )"
Has the effect of clicking a button on the current form by specifying
its name, value, or index.  Its arguments are a list of key/value
pairs.  Only one of name, number, input or value must be specified in
the keys.
.IP "* name => name" 4
.IX Item "name => name"
Clicks the button named \fIname\fR in the current form.
.IP "* number => n" 4
.IX Item "number => n"
Clicks the \fIn\fRth button in the current form. Numbering starts at 1.
.IP "* value => value" 4
.IX Item "value => value"
Clicks the button with the value \fIvalue\fR in the current form.
.ie n .IP "* input => $inputobject" 4
.el .IP "* input => \f(CW$inputobject\fR" 4
.IX Item "input => $inputobject"
Clicks on the button referenced by \f(CW$inputobject\fR, an instance of
HTML::Form::SubmitInput obtained e.g. from
.Sp
.Vb 1
\&    $mech\->current_form()\->find_input( undef, 'submit' )
.Ve
.Sp
$inputobject must belong to the current form.
.IP "* x => x" 4
.IX Item "x => x"
.PD 0
.IP "* y => y" 4
.IX Item "y => y"
.PD
These arguments (optional) allow you to specify the (x,y) coordinates
of the click.
.Sh "$mech\->\fIsubmit()\fP"
.IX Subsection "$mech->submit()"
Submits the page, without specifying a button to click.  Actually,
no button is clicked at all.
.PP
This used to be a synonym for \f(CW\*(C`$mech\->click( 'submit' )\*(C'\fR, but is no
longer so.
.Sh "$mech\->submit_form( ... )"
.IX Subsection "$mech->submit_form( ... )"
This method lets you select a form from the previously fetched page,
fill in its fields, and submit it. It combines the form_number/form_name,
set_fields and click methods into one higher level call. Its arguments
are a list of key/value pairs, all of which are optional.
.IP "* fields => \e%fields" 4
.IX Item "fields => %fields"
Specifies the fields to be filled in the current form.
.IP "* with_fields => \e%fields" 4
.IX Item "with_fields => %fields"
Probably all you need for the common case. It combines a smart form selector
and data setting in one operation. It selects the first form that contains all
fields mentioned in \f(CW\*(C`\e%fields\*(C'\fR.  This is nice because you don't need to know
the name or number of the form to do this.
.Sp
(calls \f(CW\*(C`form_with_fields\*(C'\fR and \f(CW\*(C`\f(CIset_fields()\f(CW\*(C'\fR).
.Sp
If you choose this, the form_number, form_name and fields options will be ignored.
.IP "* form_number => n" 4
.IX Item "form_number => n"
Selects the \fIn\fRth form (calls \f(CW\*(C`\f(CIform_number()\f(CW\*(C'\fR).  If this parm is not
specified, the currently-selected form is used.
.IP "* form_name => name" 4
.IX Item "form_name => name"
Selects the form named \fIname\fR (calls \f(CW\*(C`\f(CIform_name()\f(CW\*(C'\fR)
.IP "* button => button" 4
.IX Item "button => button"
Clicks on button \fIbutton\fR (calls \f(CW\*(C`\f(CIclick()\f(CW\*(C'\fR)
.IP "* x => x, y => y" 4
.IX Item "x => x, y => y"
Sets the x or y values for \f(CW\*(C`\f(CIclick()\f(CW\*(C'\fR
.PP
If no form is selected, the first form found is used.
.PP
If \fIbutton\fR is not passed, then the \f(CW\*(C`\f(CIsubmit()\f(CW\*(C'\fR method is used instead.
.PP
Returns an HTTP::Response object.
.SH "MISCELLANEOUS METHODS"
.IX Header "MISCELLANEOUS METHODS"
.ie n .Sh "$mech\->add_header( name => $value\fP [, name => \f(CW$value... ] )"
.el .Sh "$mech\->add_header( name => \f(CW$value\fP [, name => \f(CW$value\fP... ] )"
.IX Subsection "$mech->add_header( name => $value [, name => $value... ] )"
Sets \s-1HTTP\s0 headers for the agent to add or remove from the \s-1HTTP\s0 request.
.PP
.Vb 1
\&    $mech\->add_header( Encoding => 'text/klingon' );
.Ve
.PP
If a \fIvalue\fR is \f(CW\*(C`undef\*(C'\fR, then that header will be removed from any
future requests.  For example, to never send a Referer header:
.PP
.Vb 1
\&    $mech\->add_header( Referer => undef );
.Ve
.PP
If you want to delete a header, use \f(CW\*(C`delete_header\*(C'\fR.
.PP
Returns the number of name/value pairs added.
.PP
\&\fB\s-1NOTE\s0\fR: This method was very different in WWW::Mechanize before 1.00.
Back then, the headers were stored in a package hash, not as a member of
the object instance.  Calling \f(CW\*(C`add_header()\*(C'\fR would modify the headers
for every WWW::Mechanize object, even after your object no longer existed.
.Sh "$mech\->delete_header( name [, name ... ] )"
.IX Subsection "$mech->delete_header( name [, name ... ] )"
Removes \s-1HTTP\s0 headers from the agent's list of special headers.  For
instance, you might need to do something like:
.PP
.Vb 2
\&    # Don't send a Referer for this URL
\&    $mech\->add_header( Referer => undef );
.Ve
.PP
.Vb 2
\&    # Get the URL
\&    $mech\->get( $url );
.Ve
.PP
.Vb 2
\&    # Back to the default behavior
\&    $mech\->delete_header( 'Referer' );
.Ve
.Sh "$mech\->quiet(true/false)"
.IX Subsection "$mech->quiet(true/false)"
Allows you to suppress warnings to the screen.
.PP
.Vb 3
\&    $mech\->quiet(0); # turns on warnings (the default)
\&    $mech\->quiet(1); # turns off warnings
\&    $mech\->quiet();  # returns the current quietness status
.Ve
.ie n .Sh "$mech\->stack_depth( $max_depth )"
.el .Sh "$mech\->stack_depth( \f(CW$max_depth\fP )"
.IX Subsection "$mech->stack_depth( $max_depth )"
Get or set the page stack depth. Use this if you're doing a lot of page
scraping and running out of memory.
.PP
A value of 0 means \*(L"no history at all.\*(R"  By default, the max stack depth
is humongously large, effectively keeping all history.
.ie n .Sh "$mech\->save_content( $filename )"
.el .Sh "$mech\->save_content( \f(CW$filename\fP )"
.IX Subsection "$mech->save_content( $filename )"
Dumps the contents of \f(CW\*(C`$mech\->content\*(C'\fR into \fI$filename\fR.
\&\fI$filename\fR will be overwritten.  Dies if there are any errors.
.SH "OVERRIDDEN LWP::UserAgent METHODS"
.IX Header "OVERRIDDEN LWP::UserAgent METHODS"
.Sh "$mech\->\fIclone()\fP"
.IX Subsection "$mech->clone()"
Clone the mech object. We override here to be sure the cookie jar
gets copied over
.Sh "$mech\->\fIredirect_ok()\fP"
.IX Subsection "$mech->redirect_ok()"
An overloaded version of \f(CW\*(C`redirect_ok()\*(C'\fR in LWP::UserAgent.
This method is used to determine whether a redirection in the request
should be followed.
.ie n .Sh "$mech\->request( $request\fP [, \f(CW$arg\fP [, \f(CW$size]])"
.el .Sh "$mech\->request( \f(CW$request\fP [, \f(CW$arg\fP [, \f(CW$size\fP]])"
.IX Subsection "$mech->request( $request [, $arg [, $size]])"
Overloaded version of \f(CW\*(C`request()\*(C'\fR in LWP::UserAgent.  Performs
the actual request.  Normally, if you're using WWW::Mechanize, it's
because you don't want to deal with this level of stuff anyway.
.PP
Note that \f(CW$request\fR will be modified.
.PP
Returns an HTTP::Response object.
.ie n .Sh "$mech\->update_html( $html )"
.el .Sh "$mech\->update_html( \f(CW$html\fP )"
.IX Subsection "$mech->update_html( $html )"
Allows you to replace the \s-1HTML\s0 that the mech has found.  Updates the
forms and links parse-trees that the mech uses internally.
.PP
Say you have a page that you know has malformed output, and you want to
update it so the links come out correctly:
.PP
.Vb 3
\&    my $html = $mech\->content;
\&    $html =~ s[</option>.{0,3}</td>][</option></select></td>]isg;
\&    $mech\->update_html( $html );
.Ve
.PP
This method is also used internally by the mech itself to update its
own \s-1HTML\s0 content when loading a page. This means that if you would
like to \fIsystematically\fR perform the above \s-1HTML\s0 substitution, you
would overload \fIupdate_html\fR in a subclass thusly:
.PP
.Vb 2
\&   package MyMech;
\&   use base 'WWW::Mechanize';
.Ve
.PP
.Vb 5
\&   sub update_html {
\&       my ($self, $html) = @_;
\&       $html =~ s[</option>.{0,3}</td>][</option></select></td>]isg;
\&       $self\->WWW::Mechanize::update_html( $html );
\&   }
.Ve
.PP
If you do this, then the mech will use the tidied-up \s-1HTML\s0 instead of
the original both when parsing for its own needs, and for returning to
you through \*(L"content\*(R".
.PP
Overloading this method is also the recommended way of implementing
extra validation steps (e.g. link checkers) for every \s-1HTML\s0 page
received.  \*(L"warn\*(R" and \*(L"die\*(R" would then come in handy to signal
validation errors.
.ie n .Sh "$mech\->credentials( $username\fP, \f(CW$password )"
.el .Sh "$mech\->credentials( \f(CW$username\fP, \f(CW$password\fP )"
.IX Subsection "$mech->credentials( $username, $password )"
Provide credentials to be used for \s-1HTTP\s0 Basic authentication for all sites and
realms until further notice.
.PP
The four argument form described in LWP::UserAgent is still supported.
.SH "INTERNAL-ONLY METHODS"
.IX Header "INTERNAL-ONLY METHODS"
These methods are only used internally.  You probably don't need to
know about them.
.ie n .Sh "$mech\->_update_page($request, $response)"
.el .Sh "$mech\->_update_page($request, \f(CW$response\fP)"
.IX Subsection "$mech->_update_page($request, $response)"
Updates all internal variables in \f(CW$mech\fR as if \f(CW$request\fR was just
performed, and returns \f(CW$response\fR. The page stack is \fBnot\fR altered by
this method, it is up to caller (e.g. \*(L"request\*(R") to do that.
.ie n .Sh "$mech\->_modify_request( $req )"
.el .Sh "$mech\->_modify_request( \f(CW$req\fP )"
.IX Subsection "$mech->_modify_request( $req )"
Modifies a HTTP::Request before the request is sent out,
for both \s-1GET\s0 and \s-1POST\s0 requests.
.PP
We add a \f(CW\*(C`Referer\*(C'\fR header, as well as header to note that we can accept gzip
encoded content, if Compress::Zlib is installed.
.Sh "$mech\->\fI_make_request()\fP"
.IX Subsection "$mech->_make_request()"
Convenience method to make it easier for subclasses like
WWW::Mechanize::Cached to intercept the request.
.Sh "$mech\->\fI_reset_page()\fP"
.IX Subsection "$mech->_reset_page()"
Resets the internal fields that track page parsed stuff.
.Sh "$mech\->\fI_extract_links()\fP"
.IX Subsection "$mech->_extract_links()"
Extracts links from the content of a webpage, and populates the \f(CW\*(C`{links}\*(C'\fR
property with WWW::Mechanize::Link objects.
.ie n .Sh "$mech\->\fI_push_page_stack()\fP / $mech\fP\->\fI_pop_page_stack()"
.el .Sh "$mech\->\fI_push_page_stack()\fP / \f(CW$mech\fP\->\fI_pop_page_stack()\fP"
.IX Subsection "$mech->_push_page_stack() / $mech->_pop_page_stack()"
The agent keeps a stack of visited pages, which it can pop when it needs
to go \s-1BACK\s0 and so on.
.PP
The current page needs to be pushed onto the stack before we get a new
page, and the stack needs to be popped when \s-1BACK\s0 occurs.
.PP
Neither of these take any arguments, they just operate on the \f(CW$mech\fR
object.
.ie n .Sh "warn( @messages )"
.el .Sh "warn( \f(CW@messages\fP )"
.IX Subsection "warn( @messages )"
Centralized warning method, for diagnostics and non-fatal problems.
Defaults to calling \f(CW\*(C`CORE::warn\*(C'\fR, but may be overridden by setting
\&\f(CW\*(C`onwarn\*(C'\fR in the constructor.
.ie n .Sh "die( @messages )"
.el .Sh "die( \f(CW@messages\fP )"
.IX Subsection "die( @messages )"
Centralized error method.  Defaults to calling \f(CW\*(C`CORE::die\*(C'\fR, but
may be overridden by setting \f(CW\*(C`onerror\*(C'\fR in the constructor.
.SH "WWW::MECHANIZE'S SUBVERSION REPOSITORY"
.IX Header "WWW::MECHANIZE'S SUBVERSION REPOSITORY"
Mech is hosted by the kind generosity of Ask and Robert,
maintainers of perl.org.  The Subversion repository is at
<http://svn.perl.org/modules/www\-mechanize>.
.SH "OTHER DOCUMENTATION"
.IX Header "OTHER DOCUMENTATION"
.Sh "\fISpidering Hacks\fP, by Kevin Hemenway and Tara Calishain"
.IX Subsection "Spidering Hacks, by Kevin Hemenway and Tara Calishain"
\&\fISpidering Hacks\fR from O'Reilly
(<http://www.oreilly.com/catalog/spiderhks/>) is a great book for anyone
wanting to know more about screen-scraping and spidering.
.PP
There are six hacks that use Mech or a Mech derivative:
.IP "#21 WWW::Mechanize 101" 4
.IX Item "#21 WWW::Mechanize 101"
.PD 0
.IP "#22 Scraping with WWW::Mechanize" 4
.IX Item "#22 Scraping with WWW::Mechanize"
.IP "#36 Downloading Images from Webshots" 4
.IX Item "#36 Downloading Images from Webshots"
.IP "#44 Archiving Yahoo! Groups Messages with WWW::Yahoo::Groups" 4
.IX Item "#44 Archiving Yahoo! Groups Messages with WWW::Yahoo::Groups"
.IP "#64 Super Author Searching" 4
.IX Item "#64 Super Author Searching"
.IP "#73 Scraping \s-1TV\s0 Listings" 4
.IX Item "#73 Scraping TV Listings"
.PD
.PP
The book was also positively reviewed on Slashdot:
<http://books.slashdot.org/article.pl?sid=03/12/11/2126256>
.SH "ONLINE RESOURCES AND SUPPORT"
.IX Header "ONLINE RESOURCES AND SUPPORT"
.IP "* \s-1LWP\s0 mailing list" 4
.IX Item "LWP mailing list"
The \s-1LWP\s0 mailing list is at
<http://lists.perl.org/showlist.cgi?name=libwww>, and is more
user-oriented and well-populated than the WWW::Mechanize Development
list.  This is a good list for Mech users, since \s-1LWP\s0 is the basis
for Mech.
.IP "* Perlmonks" 4
.IX Item "Perlmonks"
<http://perlmonks.org> is an excellent community of support, and
many questions about Mech have already been answered there.
.IP "* WWW::Mechanize::Examples" 4
.IX Item "WWW::Mechanize::Examples"
A random array of examples submitted by users, included with the
Mechanize distribution.
.SH "ARTICLES ABOUT WWW::MECHANIZE"
.IX Header "ARTICLES ABOUT WWW::MECHANIZE"
.IP "* <http://www\-128.ibm.com/developerworks/linux/library/wa\-perlsecure.html>" 4
.IX Item "<http://www-128.ibm.com/developerworks/linux/library/wa-perlsecure.html>"
\&\s-1IBM\s0 article \*(L"Secure Web site access with Perl\*(R"
.IP "* <http://www.oreilly.com/catalog/googlehks2/chapter/hack84.pdf>" 4
.IX Item "<http://www.oreilly.com/catalog/googlehks2/chapter/hack84.pdf>"
Leland Johnson's hack #84 in \fIGoogle Hacks, 2nd Edition\fR is
an example of a production script that uses WWW::Mechanize and
HTML::TableContentParser. It takes in keywords and returns the estimated
price of these keywords on Google's AdWords program.
.IP "* <http://www.perl.com/pub/a/2004/06/04/recorder.html>" 4
.IX Item "<http://www.perl.com/pub/a/2004/06/04/recorder.html>"
Linda Julien writes about using HTTP::Recorder to create WWW::Mechanize
scripts.
.IP "* <http://www.developer.com/lang/other/article.php/3454041>" 4
.IX Item "<http://www.developer.com/lang/other/article.php/3454041>"
Jason Gilmore's article on using WWW::Mechanize for scraping sales
information from Amazon and eBay.
.IP "* <http://www.perl.com/pub/a/2003/01/22/mechanize.html>" 4
.IX Item "<http://www.perl.com/pub/a/2003/01/22/mechanize.html>"
Chris Ball's article about using WWW::Mechanize for scraping \s-1TV\s0
listings.
.IP "* <http://www.stonehenge.com/merlyn/LinuxMag/col47.html>" 4
.IX Item "<http://www.stonehenge.com/merlyn/LinuxMag/col47.html>"
Randal Schwartz's article on scraping Yahoo News for images.  It's
already out of date: He manually walks the list of links hunting
for matches, which wouldn't have been necessary if the \f(CW\*(C`find_link()\*(C'\fR
method existed at press time.
.IP "* <http://www.perladvent.org/2002/16th/>" 4
.IX Item "<http://www.perladvent.org/2002/16th/>"
WWW::Mechanize on the Perl Advent Calendar, by Mark Fowler.
.IP "* <http://www.linux\-magazin.de/Artikel/ausgabe/2004/03/perl/perl.html>" 4
.IX Item "<http://www.linux-magazin.de/Artikel/ausgabe/2004/03/perl/perl.html>"
Michael Schilli's article on Mech and WWW::Mechanize::Shell for the
German magazine \fILinux Magazin\fR.
.Sh "Other modules that use Mechanize"
.IX Subsection "Other modules that use Mechanize"
Here are modules that use or subclass Mechanize.  Let me know of any others:
.IP "* Finance::Bank::LloydsTSB" 4
.IX Item "Finance::Bank::LloydsTSB"
.PD 0
.IP "* HTTP::Recorder" 4
.IX Item "HTTP::Recorder"
.PD
Acts as a proxy for web interaction, and then generates WWW::Mechanize scripts.
.IP "* Win32::IE::Mechanize" 4
.IX Item "Win32::IE::Mechanize"
Just like Mech, but using Microsoft Internet Explorer to do the work.
.IP "* WWW::Bugzilla" 4
.IX Item "WWW::Bugzilla"
.PD 0
.IP "* WWW::CheckSite" 4
.IX Item "WWW::CheckSite"
.IP "* WWW::Google::Groups" 4
.IX Item "WWW::Google::Groups"
.IP "* WWW::Hotmail" 4
.IX Item "WWW::Hotmail"
.IP "* WWW::Mechanize::Cached" 4
.IX Item "WWW::Mechanize::Cached"
.IP "* WWW::Mechanize::FormFiller" 4
.IX Item "WWW::Mechanize::FormFiller"
.IP "* WWW::Mechanize::Shell" 4
.IX Item "WWW::Mechanize::Shell"
.IP "* WWW::Mechanize::Sleepy" 4
.IX Item "WWW::Mechanize::Sleepy"
.IP "* WWW::Mechanize::SpamCop" 4
.IX Item "WWW::Mechanize::SpamCop"
.IP "* WWW::Mechanize::Timed" 4
.IX Item "WWW::Mechanize::Timed"
.IP "* WWW::SourceForge" 4
.IX Item "WWW::SourceForge"
.IP "* WWW::Yahoo::Groups" 4
.IX Item "WWW::Yahoo::Groups"
.PD
.SH "REQUESTS & BUGS"
.IX Header "REQUESTS & BUGS"
Please report any requests, suggestions or (gasp!) bugs via the
excellent \s-1RT\s0 bug-tracking system at http://rt.cpan.org/, or email to
bug\-WWW\-Mechanize@rt.cpan.org.  This makes it much easier for me to
track things.
.PP
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW\-Mechanize> is the \s-1RT\s0 queue
for Mechanize.  Please check to see if your bug has already been reported.
.PP
Please note that this is \s-1NOT\s0 for support requests.  Please be sure
to read the \s-1FAQ\s0 if you have support requests.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to the numerous people who have helped out on WWW::Mechanize in
one way or another, including
Kirrily Robert for the orignal \f(CW\*(C`WWW::Automate\*(C'\fR,
Peteris Krumins,
Rafael Kitover,
David Steinbrunner,
Kevin Falcone,
Mike O'Regan,
Mark Stosberg,
Uri Guttman,
Peter Scott,
Phillipe Bruhat,
Ian Langworth,
John Beppu,
Gavin Estey,
Jim Brandt,
Ask Bjoern Hansen,
Greg Davies,
Ed Silva,
Mark-Jason Dominus,
Autrijus Tang,
Mark Fowler,
Stuart Children,
Max Maischein,
Meng Wong,
Prakash Kailasa,
Abigail,
Jan Pazdziora,
Dominique Quatravaux,
Scott Lanning,
Rob Casey,
Leland Johnson,
Joshua Gatcomb,
Julien Beasley,
Abe Timmerman,
Peter Stevens,
Pete Krawczyk,
and the late great Iain Truskett.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005\-2007 Andy Lester. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
